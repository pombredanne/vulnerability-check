import os
import json
import time
import requests
import zipfile
import json
import sqlite3
from cvss import CVSS3
import concurrent.futures


class MITREDataImporter:
    def __init__(self, database_file='cve_data.db'):
        """
        Initialize the CVEProcessor with the path to the SQLite database file.

        Args:
            database_file (str): Path to the SQLite database file.
        """
        self.db_file = database_file

    def init_db(self):
        """
        Initializes the SQLite database and creates the necessary table if it doesn't exist.
        """
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()

        # Create table if it doesn't exist
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS mitre_cve (
            cve_id TEXT PRIMARY KEY,
            description TEXT,
            base_severity TEXT,
            confidentiality_impact TEXT,
            integrity_impact TEXT,
            availability_impact TEXT,
            vector TEXT,
            impact TEXT,
            state TEXT
        )
        ''')
        conn.commit()
        conn.close()

    @staticmethod
    def process_cvss_vector(vector):
        """
        Processes the CVSS vector and returns the impact values.

        Args:
            vector (str): The CVSS vector string.

        Returns:
            tuple: A tuple containing the confidentiality impact, integrity impact, and availability impact.
        """
        c = CVSS3(vector)
        data = c.as_json()
        return (
            data.get('confidentialityImpact', ''),
            data.get('integrityImpact', ''),
            data.get('availabilityImpact', '')
        )

    @staticmethod
    def get_cve_impact(json_data):
        """
        Retrieves the impact of a CVE from the JSON data.

        Args:
            json_data (dict): The JSON data of a CVE entry.

        Returns:
            str: The impact of the CVE.
        """
        descriptions = [desc["description"] for desc in json_data["descriptions"]]
        impact = ", ".join(descriptions)  # Convert the descriptions to text
        return impact

    def download_cve_file(self):
        """
        Downloads CVE files from the NVD for the specified range of years.
        """
        download_url = "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
        output_folder = "cve-json"

        # Create the output folder if it doesn't exist
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        response = requests.get(download_url)

        if response.status_code == 200:
            zip_file_path = os.path.join(output_folder, "cvelistV5-main.zip")
            with open(zip_file_path, 'wb') as zip_file:
                zip_file.write(response.content)
            print(f"CVE file downloaded and saved as: {zip_file_path}")

            # Unzip the downloaded file
            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                zip_ref.extractall(output_folder)
            print(f"Unzipped CVE file saved in: {output_folder}")

            # Remove the downloaded ZIP file
            os.remove(zip_file_path)
            print(f"Downloaded ZIP file removed: {zip_file_path}")
        else:
            print(f"Failed to download CVE file")

    @staticmethod
    def process_json_file(file_path):
        """
        Processes a JSON file and returns the relevant metadata and data.

        Args:
            file_path (str): The path to the JSON file.

        Returns:
            tuple: A tuple containing the CVE metadata and data.
        """
        with open(file_path, "r", encoding='utf8') as json_file:
            try:
                data = json.load(json_file)
                return data['cveMetadata'], data['containers']['cna']
            except json.JSONDecodeError:
                print(f"Error reading JSON file: {file_path}")
        json_file.close()

    def read_json_files(self, root_dir):
        """
        Reads and processes all JSON files in the specified directory.

        Args:
            root_dir (str): The root directory containing the JSON files.

        Returns:
            list: A list of CVE entries.
        """
        cve_list = []
        start_time = time.time()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            for root, dirs, files in os.walk(root_dir):
                for file in files:
                    if file.endswith(".json"):
                        file_path = os.path.join(root, file)
                        future = executor.submit(self.get_cve_detail, file_path)
                        cve_list.append(future.result())

        end_time = time.time()
        execution_time = end_time - start_time
        print("Program finished in", execution_time, "seconds.")
        print("Total CVEs:", len(cve_list))
        return cve_list

    def get_cve_detail(self, file_path):
        """
        Processes a JSON file and extracts the relevant CVE details.

        Args:
            file_path (str): The path to the JSON file.

        Returns:
            dict: A dictionary containing the CVE details.
        """
        tmp = {}
        meta_data, data = self.process_json_file(file_path)
        tmp['cve_id'] = meta_data['cveId']
        if meta_data['state'] == "REJECTED":
            tmp['base_severity'] = None
            tmp['confidentiality_impact'] = None
            tmp['integrity_impact'] = None
            tmp['availability_impact'] = None
            tmp['vector'] = None
            tmp['impact'] = None
            tmp['description'] = data['rejectedReasons'][0]['value']
        else:
            tmp['description'] = data['descriptions'][0]['value']
            tmp['impact'] = self.get_cve_impact(data['problemTypes'][0]) if "problemTypes" in data else None

        tmp['state'] = meta_data['state']
        tmp['base_severity'] = None
        tmp['confidentiality_impact'] = None
        tmp['integrity_impact'] = None
        tmp['availability_impact'] = None
        tmp['vector'] = None

        if 'metrics' in data:
            if "cvssV3_0" in data['metrics'][0]:
                tmp['base_severity'] = data['metrics'][0]['cvssV3_0'].get('baseSeverity', '')
                tmp['confidentiality_impact'] = data['metrics'][0]['cvssV3_0'].get('confidentialityImpact', '')
                tmp['integrity_impact'] = data['metrics'][0]['cvssV3_0'].get('integrityImpact', '')
                tmp['availability_impact'] = data['metrics'][0]['cvssV3_0'].get('availabilityImpact', '')
                tmp['vector'] = data['metrics'][0]['cvssV3_0'].get('vectorString', '')
            elif "cvssV3_1" in data['metrics'][0]:
                tmp['base_severity'] = data['metrics'][0]['cvssV3_1'].get('baseSeverity', '')
                tmp['vector'] = data['metrics'][0]['cvssV3_1'].get('vectorString', '')
                tmp['confidentiality_impact'], tmp['integrity_impact'], tmp['availability_impact'] = self.process_cvss_vector(
                    tmp['vector'])

        return tmp

    def bulk_insert_cve_to_db(self, cve_list):
        """
        Inserts a list of CVE data into the SQLite database in a bulk manner.

        Args:
            cve_list (list): A list of CVE entries.
        """
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        # Extract required fields and form a list of tuples
        data_list = [(item['cve_id'], item['description'], item['base_severity'], item['confidentiality_impact'],
                      item['integrity_impact'], item['availability_impact'], item['impact'], item['vector'],
                      item['state']) for item in cve_list]
        try:
            # Insert the data
            cursor.executemany('''
                INSERT INTO mitre_cve (cve_id, description, base_severity, confidentiality_impact,
                integrity_impact, availability_impact, impact, vector, state)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', data_list)

            # Commit the changes and close the connection
            conn.commit()
        except Exception as error:
            # handle the exception
            print("An exception occurred:", error)

        conn.close()

    def find_missing_cve_in_nvdcve(self):
        """
        Finds and updates missing CVE entries in the database based on existing entries.
        """
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT cve_id FROM mitre_cve WHERE base_severity is NULL")
        rows = cursor.fetchall()
        missing_cve = [row[0] for row in rows]
        for cve in missing_cve:
            cursor.execute("SELECT base_severity, confidentiality_impact, integrity_impact, availability_impact FROM cve_data WHERE cve_id=?", (cve,))
            existing_entry = cursor.fetchone()
            if existing_entry:
                # Update the 'description' field for the existing entry
                cursor.execute("UPDATE mitre_cve SET base_severity=?, confidentiality_impact=?, integrity_impact=?, availability_impact=? WHERE cve_id=?", (existing_entry[0], existing_entry[1], existing_entry[2], existing_entry[3], cve))
                print("Updated CIA impact for: " + cve)
            else:
                print("Did not exist CVE: " + cve)
        conn.commit()
        conn.close()

    def main(self):
        """
        The main entry point of the program.
        """
        #self.download_cve_file()
        for year in range(1999, 2024):
            root_directory = f"cve-json/cvelistV5-main/cves/{year}"
            self.init_db()
            cve_list = []
            cve_list = self.read_json_files(root_directory)
            print(year, len(cve_list))
            self.bulk_insert_cve_to_db(cve_list)

        self.find_missing_cve_in_nvdcve()


# if __name__ == "__main__":
#     processor = MITREDataImporter()
#     processor.main()
